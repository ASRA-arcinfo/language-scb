{ "name": "Scada Basic",
  "scopeName": "source.sv",
  "fileTypes": ["scb"],
  "patterns": [


    { "match": "(?i:\\b(Acos|Addstring|Alarm|Alarmdisplay|Alloc_Buffer|Animation|Application|Asc|Asciifield|Asin|Assoclabel|AssociatedActions|Atan|Bacnet|Beep|Bin|Break|BufToExcel|BufToFile|Caption|Cget_Buffer|Chart|Checklist|Chr|Cimway|Cmpstring|ComboBox|Const|Convert|Copy_Buffer|Cos|Crontab|Cyclic|DateTime|DateTimeString|DateTimeValue|Dde|DdeConv|Declare|Delay|Dget_Buffer|Dval|Email|Error|Event|ExcelToBuf|Export|Export_Log|Export_Trend|Exp|Expression|Fclose|Feof|Fgetc|Fgets|FileToBuf|Fopen|Format|Formula|Fputc|Fputs|Fread|Free_Buffer|Fseek|Fstat|Ftp|Fwrite|GetArg|GetProjectDir|GetTree|GroupAlarm|HardCopy|Hex|History|Iget_Buffer|Irand|Ival|Key|Lan|Language|Lcase|Left|Len|Lget_Buffer|ListBox|Lonworks|Log|LogDisplay|Logical|Logical64|lPrint|Ltrim|Lval|M104|M61850|MapDisplay|Mdnp3|Mid|Multimedia|Oct|Opc|OptionList|Population|Pow|Print|Printer|Program|Put_Buffer|Recipe|Refresh_Db|Region|RegVar2d|Rename|Return|Right|Rtrim|Selector|SendList|Seq_Buffer|Sin|Sms|Snmp|Space|Sqrt|Station_Filter|Stop|String|Sval|Svala|SvBatch|SvBranch|SvKey|SvLog|SvSql|SvTrend|System|Tan|Temporary_Db|TextVar|Toc|Tod|ToDouble|ToHms|Toi|Tol|Toll|Tos|Trace|TraceOn|TraceOff|Tree|TreeView|Trend|Ucase|Unlink|Variable|WebVue|Window|XmlPath)\\b)\\s*(?=\\()|(?i:(integer|str|long|single|double);)|(?i:\\b(dim|as)\\b)",
      "name": "keyword.source.sv",
      "comment": "Scada Basic instructions & keywords"
    },

    { "match": "(?i:^\\s*sub\\s*([a-zA-Z_]\\w*)\\s*(\\()([^)]*)(\\)).*\\n?)|(?i:^\\s*end sub.*\\n?)",

      "name": "support.function.source.sv",
      "comment": "Scada Basic function"

    },

    { "match": "^\\s*'\\s*.*",

      "name": "comment.line.source.sv",
      "comment": "Scada Basic comment"
    },

    {
        "include": "#preprocessor-rule-enabled"
    },
    {
        "include": "#preprocessor-rule-disabled"
    },
    {
        "include": "#preprocessor-rule-other"
    },
    {
        "include": "#comments"
    },
    {
        "match": "\\b(namespace|declare|dim|var|end|case|continue|default|do|loop|else|for|goto|if|elseif|then|end if|return|next|function|sub|until|select|wend|with|while|as)\\b",
        "name": "keyword.control.SCADABASIC"
    },
    {
        "match": "\\b(pointer|POINTER|ptr|PTR|unsigned|UNSIGNED)\\b",
        "name": "storage.type.SCADABASIC"
    },
    {
        "match": "\\b(const|extern|static|byval|byref|bydesc)\\b",
        "name": "storage.modifier.SCADABASIC"
    },
    {
        "comment": "common C constant naming idiom -- kConstantVariable",
        "match": "\\bk[A-Z]\\w*\\b",
        "name": "constant.other.variable.mac-classic.SCADABASIC"
    },
    {
        "match": "\\bg[A-Z]\\w*\\b",
        "name": "variable.other.readwrite.global.mac-classic.SCADABASIC"
    },
    {
        "match": "\\bs[A-Z]\\w*\\b",
        "name": "variable.other.readwrite.static.mac-classic.SCADABASIC"
    },
    {
        "match": "\\b(NULL|true|false|TRUE|FALSE)\\b",
        "name": "constant.language.SCADABASIC"
    },
    {
        "include": "#sizeof"
    },
    {
        "match": "\\b((&(b|B)[0-1]*)(&(h|H)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b",
        "name": "constant.numeric.SCADABASIC"
    },
    {
        "begin": "\"",
        "beginCaptures": {
            "0": {
                "name": "punctuation.definition.string.begin.SCADABASIC"
            }
        },
        "end": "\"",
        "endCaptures": {
            "0": {
                "name": "punctuation.definition.string.end.SCADABASIC"
            }
        },
        "name": "string.quoted.double.SCADABASIC",
        "patterns": [
            {
                "include": "#string_escaped_char"
            },
            {
                "include": "#string_placeholder"
            }
        ]
    },
    {
        "begin": "(?x)\n        \t\t^\\s*\\#\\s*(define)\\s+             # define\n        \t\t((?<id>[a-zA-Z_][a-zA-Z0-9_]*))  # macro name\n        \t\t(?:                              # and optionally:\n        \t\t    (\\()                         # an open parenthesis\n        \t\t        (\n        \t\t            \\s* \\g<id> \\s*       # first argument\n        \t\t            ((,) \\s* \\g<id> \\s*)*  # additional arguments\n        \t\t            (?:\\.\\.\\.)?          # varargs ellipsis?\n        \t\t        )\n        \t\t    (\\))                         # a close parenthesis\n        \t\t)?\n        \t",
        "beginCaptures": {
            "1": {
                "name": "keyword.control.import.define.SCADABASIC"
            },
            "2": {
                "name": "entity.name.function.preprocessor.SCADABASIC"
            },
            "4": {
                "name": "punctuation.definition.parameters.begin.SCADABASIC"
            },
            "5": {
                "name": "variable.parameter.preprocessor.SCADABASIC"
            },
            "7": {
                "name": "punctuation.separator.parameters.SCADABASIC"
            },
            "8": {
                "name": "punctuation.definition.parameters.end.SCADABASIC"
            }
        },
        "end": "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        "name": "meta.preprocessor.macro.SCADABASIC",
        "patterns": [
            {
                "match": "(?>\\\\\\s*\\n)",
                "name": "punctuation.separator.continuation.SCADABASIC"
            },
            {
                "include": "$base"
            }
        ]
    },
    {
        "begin": "^\\s*#\\s*(error|warning)\\b",
        "captures": {
            "1": {
                "name": "keyword.control.import.error.SCADABASIC"
            }
        },
        "end": "(?<!\\\\)(?=\\n)",
        "name": "meta.preprocessor.diagnostic.SCADABASIC",
        "patterns": [
            {
                "match": "(?>\\\\\\s*\\n)",
                "name": "punctuation.separator.continuation.SCADABASIC"
            }
        ]
    },
    {
        "begin": "^\\s*#\\s*(include)\\b\\s+",
        "captures": {
            "1": {
                "name": "keyword.control.import.include.SCADABASIC"
            }
        },
        "end": "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        "name": "meta.preprocessor.SCADABASIC.include",
        "patterns": [
            {
                "match": "(?>\\\\\\s*\\n)",
                "name": "punctuation.separator.continuation.SCADABASIC"
            },
            {
                "begin": "\"",
                "beginCaptures": {
                    "0": {
                        "name": "punctuation.definition.string.begin.SCADABASIC"
                    }
                },
                "end": "\"",
                "endCaptures": {
                    "0": {
                        "name": "punctuation.definition.string.end.SCADABASIC"
                    }
                },
                "name": "string.quoted.double.include.SCADABASIC"
            }
        ]
    },
    {
        "include": "#pragma-mark"
    },
    {
        "begin": "^\\s*#\\s*(assert|libpath|lang|define|defined|elseif|else|if|ifdef|ifndef|line|pragma|undef|print|error|inclib|macro|endmacro)\\b",
        "captures": {
            "1": {
                "name": "keyword.control.import.SCADABASIC"
            }
        },
        "end": "(?=(?://|/\\*))|(?<!\\\\)(?=\\n)",
        "name": "meta.preprocessor.SCADABASIC",
        "patterns": [
            {
                "match": "(?>\\\\\\s*\\n)",
                "name": "punctuation.separator.continuation.SCADABASIC"
            }
        ]
    },
    {
        "match": "\\b(byte|ubyte|short|ushort|integer|uinteger|long|ulong|longint|ulongint|double|single|object|any|string|zstring|wstring)\\b",
        "name": "support.type.sys-types.SCADABASIC"
    },
    {
        "match": "\\b(pthread_attr_t|pthread_cond_t|pthread_condattr_t|pthread_mutex_t|pthread_mutexattr_t|pthread_once_t|pthread_rwlock_t|pthread_rwlockattr_t|pthread_t|pthread_key_t)\\b",
        "name": "support.type.pthread.SCADABASIC"
    },
    {
        "match": "\\b(int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|int_least8_t|int_least16_t|int_least32_t|int_least64_t|uint_least8_t|uint_least16_t|uint_least32_t|uint_least64_t|int_fast8_t|int_fast16_t|int_fast32_t|int_fast64_t|uint_fast8_t|uint_fast16_t|uint_fast32_t|uint_fast64_t|intptr_t|uintptr_t|intmax_t|intmax_t|uintmax_t|uintmax_t)\\b",
        "name": "support.type.stdint.SCADABASIC"
    },
    {
        "comment": "Reserved POSIX types",
        "match": "\\b([a-z0-9_]+_t)\\b",
        "name": "support.type.posix-reserved.SCADABASIC"
    },
    {
        "include": "#block"
    },
    {
        "begin": "(?x)\n    \t\t(?:  ^                                 # begin-of-line\n    \t\t  |  \n    \t\t     (?: (?= \\s )           (?<!else|new|return) (?<=\\w)      #  or word + space before name\n    \t\t       | (?= \\s*[A-Za-z_] ) (?<!&&)       (?<=[*&>])   #  or type modifier before name\n    \t\t     )\n    \t\t)\n    \t\t(\\s*) (?!(while|for|do|if|else|select|case|enum|return|sizeof|[cr]?iterate)\\s*\\()\n    \t\t(\n    \t\t\t(?: [A-Za-z_][A-Za-z0-9_]*+ | :: )++ |                  # actual name\n    \t\t\t(?: (?<=operator) (?: [-*&<>=+!]+ | \\(\\) | \\[\\] ) )  # if it is a C++ operator\n    \t\t)\n    \t\t \\s*(?=\\()",
        "beginCaptures": {
            "1": {
                "name": "punctuation.whitespace.function.leading.SCADABASIC"
            },
            "3": {
                "name": "entity.name.function.SCADABASIC"
            },
            "4": {
                "name": "punctuation.definition.parameters.SCADABASIC"
            }
        },
        "end": "(?<=\\})|(?=#)|(\n)",
        "name": "meta.function.SCADABASIC",
        "patterns": [
            {
                "include": "#comments"
            },
            {
                "include": "#parens"
            },
            {
                "match": "\\bconst\\b",
                "name": "storage.modifier.SCADABASIC"
            },
            {
                "include": "#block"
            }
        ]
    }

  ],
  "uuid": "ca03e751-04ef-4330-9a6b-9b99aae1c420"
}
